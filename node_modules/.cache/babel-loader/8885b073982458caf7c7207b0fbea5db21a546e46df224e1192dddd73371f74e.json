{"ast":null,"code":"var _jsxFileName = \"/media/abdulrehman/Local Disk/University Document/Semester 6/Artificial Intelligence/Projects/Object Detection/public/obj_detection_app/src/Components/web_capture.jsx\",\n  _s = $RefreshSig$();\n// WebcamCapture.js\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WebcamCapture = () => {\n  _s();\n  const [imageUrls, setImageUrls] = useState([]);\n  const [isCapturing, setIsCapturing] = useState(false);\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  // Start the webcam when the component mounts\n  useEffect(() => {\n    const startWebcam = async () => {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: true\n      });\n      videoRef.current.srcObject = stream;\n    };\n    startWebcam();\n\n    // Clean up the webcam stream when the component unmounts\n    return () => {\n      const stream = videoRef.current.srcObject;\n      const tracks = stream === null || stream === void 0 ? void 0 : stream.getTracks();\n      tracks === null || tracks === void 0 ? void 0 : tracks.forEach(track => track.stop());\n    };\n  }, []);\n\n  // Convert data URI to Blob\n  const dataURItoBlob = dataURI => {\n    const byteString = atob(dataURI.split(',')[1]);\n    const arrayBuffer = new ArrayBuffer(byteString.length);\n    const uintArray = new Uint8Array(arrayBuffer);\n    for (let i = 0; i < byteString.length; i++) {\n      uintArray[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([uintArray], {\n      type: 'image/jpeg'\n    });\n  };\n\n  // Capture image from the webcam and send it to the backend\n  const captureImage = async () => {\n    if (isCapturing) return;\n    setIsCapturing(true);\n\n    // Draw the current frame from the video element onto the canvas\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    context.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\n\n    // Get the image data as a Data URL\n    const imageData = canvas.toDataURL('image/jpeg');\n\n    // Convert the Data URL to a Blob\n    const imageBlob = dataURItoBlob(imageData);\n\n    // Prepare the FormData to send to the server\n    const formData = new FormData();\n    formData.append('image', imageBlob, 'webcam.jpg');\n    try {\n      const response = await fetch('http://localhost:3001/webcam', {\n        method: 'POST',\n        body: formData\n      });\n      const data = await response.json();\n      if (data.status === 200) {\n        setImageUrls(data.image); // Set the image URLs returned from the backend\n      } else {\n        alert('Error: ' + data.error);\n      }\n    } catch (error) {\n      alert('Error: ' + error.message);\n    } finally {\n      setIsCapturing(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Webcam Object Detection\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      width: \"640\",\n      height: \"480\",\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 83,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: \"640\",\n      height: \"480\",\n      style: {\n        display: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 84,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: captureImage,\n      disabled: isCapturing,\n      children: isCapturing ? 'Capturing...' : 'Capture Image'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: imageUrls.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: \"Detection Results:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 92,\n          columnNumber: 25\n        }, this), imageUrls.map((url, index) => /*#__PURE__*/_jsxDEV(\"img\", {\n          src: url,\n          alt: `Result ${index + 1}`,\n          width: \"320\"\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 94,\n          columnNumber: 29\n        }, this))]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 91,\n        columnNumber: 21\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 89,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 81,\n    columnNumber: 9\n  }, this);\n};\n_s(WebcamCapture, \"SU+6WY6+uCVQiMEpIBQnmkgTcF4=\");\n_c = WebcamCapture;\nexport default WebcamCapture;\nvar _c;\n$RefreshReg$(_c, \"WebcamCapture\");","map":{"version":3,"names":["React","useState","useRef","useEffect","jsxDEV","_jsxDEV","WebcamCapture","_s","imageUrls","setImageUrls","isCapturing","setIsCapturing","videoRef","canvasRef","startWebcam","stream","navigator","mediaDevices","getUserMedia","video","current","srcObject","tracks","getTracks","forEach","track","stop","dataURItoBlob","dataURI","byteString","atob","split","arrayBuffer","ArrayBuffer","length","uintArray","Uint8Array","i","charCodeAt","Blob","type","captureImage","canvas","context","getContext","drawImage","width","height","imageData","toDataURL","imageBlob","formData","FormData","append","response","fetch","method","body","data","json","status","image","alert","error","message","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","autoPlay","style","display","onClick","disabled","map","url","index","src","alt","_c","$RefreshReg$"],"sources":["/media/abdulrehman/Local Disk/University Document/Semester 6/Artificial Intelligence/Projects/Object Detection/public/obj_detection_app/src/Components/web_capture.jsx"],"sourcesContent":["// WebcamCapture.js\n\nimport React, { useState, useRef, useEffect } from 'react';\n\nconst WebcamCapture = () => {\n    const [imageUrls, setImageUrls] = useState([]);\n    const [isCapturing, setIsCapturing] = useState(false);\n    const videoRef = useRef(null);\n    const canvasRef = useRef(null);\n\n    // Start the webcam when the component mounts\n    useEffect(() => {\n        const startWebcam = async () => {\n            const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n            videoRef.current.srcObject = stream;\n        };\n\n        startWebcam();\n\n        // Clean up the webcam stream when the component unmounts\n        return () => {\n            const stream = videoRef.current.srcObject;\n            const tracks = stream?.getTracks();\n            tracks?.forEach(track => track.stop());\n        };\n    }, []);\n\n    // Convert data URI to Blob\n    const dataURItoBlob = (dataURI) => {\n        const byteString = atob(dataURI.split(',')[1]);\n        const arrayBuffer = new ArrayBuffer(byteString.length);\n        const uintArray = new Uint8Array(arrayBuffer);\n        for (let i = 0; i < byteString.length; i++) {\n            uintArray[i] = byteString.charCodeAt(i);\n        }\n        return new Blob([uintArray], { type: 'image/jpeg' });\n    };\n\n    // Capture image from the webcam and send it to the backend\n    const captureImage = async () => {\n        if (isCapturing) return;\n\n        setIsCapturing(true);\n\n        // Draw the current frame from the video element onto the canvas\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        context.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\n\n        // Get the image data as a Data URL\n        const imageData = canvas.toDataURL('image/jpeg');\n\n        // Convert the Data URL to a Blob\n        const imageBlob = dataURItoBlob(imageData);\n\n        // Prepare the FormData to send to the server\n        const formData = new FormData();\n        formData.append('image', imageBlob, 'webcam.jpg');\n\n        try {\n            const response = await fetch('http://localhost:3001/webcam', {\n                method: 'POST',\n                body: formData,\n            });\n\n            const data = await response.json();\n\n            if (data.status === 200) {\n                setImageUrls(data.image); // Set the image URLs returned from the backend\n            } else {\n                alert('Error: ' + data.error);\n            }\n        } catch (error) {\n            alert('Error: ' + error.message);\n        } finally {\n            setIsCapturing(false);\n        }\n    };\n\n    return (\n        <div>\n            <h1>Webcam Object Detection</h1>\n            <video ref={videoRef} width=\"640\" height=\"480\" autoPlay></video>\n            <canvas ref={canvasRef} width=\"640\" height=\"480\" style={{ display: 'none' }}></canvas>\n            <button onClick={captureImage} disabled={isCapturing}>\n                {isCapturing ? 'Capturing...' : 'Capture Image'}\n            </button>\n\n            <div>\n                {imageUrls.length > 0 && (\n                    <div>\n                        <h2>Detection Results:</h2>\n                        {imageUrls.map((url, index) => (\n                            <img key={index} src={url} alt={`Result ${index + 1}`} width=\"320\" />\n                        ))}\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n};\n\nexport default WebcamCapture;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}